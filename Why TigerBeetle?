https://github.com/tigerbeetle/tigerbeetle/blob/IronBeetle/Why%20TigerBeetle%3F

  1.  Purpose: track financial transactions.
  2.  Reliability ^1
  3.  Safety ^2
  4.  Availability ^2
  5.  Efficiency   ^4
  6.  Performance  ^4, 5
* 7.  Distributed system ^4 (big one, fundamental complexity!)
  8.  Simplicity ^3, 4, 5, 7 (7 --- _must_ be distributed, distributed is hard, seek simplicity elsewhere)
  9.  Building for long term ^4, 5 (https://www.youtube.com/watch?v=443UNeGrFoM&t=6949s)
  10: Mechanical Sympathy ^5
  11: Networking: just byte slices (over TCP, may UDP in the future?) ^7, 8, 9, non-byzantine ^19
      <https://github.com/tigerbeetle/tigerbeetle/blob/0.14.160/src/message_bus.zig#L699-L783>
      Episode 1 <https://www.youtube.com/watch?v=hPUL8Xo6MJw>
* 12: Double-entry accounting ^1, 3
      <https://github.com/tigerbeetle/tigerbeetle/blob/0.14.160/src/state_machine.zig#L612-L698>
      <https://github.com/tigerbeetle/tigerbeetle/blob/0.14.160/src/tigerbeetle.zig>
      Episode 2 <https://www.youtube.com/watch?v=itUzDJV3aUo>

  13: Idempotence ^3, 4
  14: IDs for transfers ^13
  15: Fixed Domain model ^8, 1
  16: Consensus ^7
* 17: Batching ^16, 6
      Episode 2 <https://www.youtube.com/watch?v=itUzDJV3aUo>
  18: _Non-polymorphic_ Batches ^17, 10
* 19: Clients are API gateways ^17
      Episode 2 <https://www.youtube.com/watch?v=itUzDJV3aUo>
  20: Bandwidth is limited ^10, 5
  21: Ring Topology for Replication: replica N replicates to replcia N+1 ^20
      Episode 3 <https://youtu.be/cjaJcEgm2RI>
  22: Linearizability: ^1, 2
  23: Embracing Concurrency ^5 (pretty big one, fundamental for performance)
* 24: Single-threaded-processing: ^12, 22
      Episode 4 <https://youtu.be/W8faGPWToms>
  25: Pipelining rather than data parallelism ^23, 24
  26: Linux, io_uring: ^2, 6 23

* 27: Static limits on everything: ^2, 4
      Episode 5 <https://youtu.be/Tl_xqv8K3B0?si=TYdQpL7WZnHsIjem>
  28: No dynamic memory allocation: ^27
  29: Backpressure for free: ^28
  30: Single request per client in flight: ^28
  31: Hash chaining: ^30
* 32: Parallel disk prefetch:
      Episode 5 <https://youtu.be/Tl_xqv8K3B0?si=TYdQpL7WZnHsIjem>

  33: Zero-copy no-padding IO: ^11, 3
  34: No dependencies: ^9
  35: Everything has 'static lifetime: ^28
* 36: Zig:
        not necessary Rust: ^34, 24, 35
        Zig in particular: ^8, 33, 28
  37: Event sourcing: 12, 2
  38: Implemented by Replicated State Machine: 37, 4, 6
  39: Hash chaining: 3, 5
  40: Prepare pipelining: 23


State-based representation:
State: HashMap<AccountId, AccountBallances>

Event-based:
State: List<Transfers>
